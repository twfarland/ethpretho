(:= fs (require "fs"))
(:= util (require "util"))
(:= _  (require "./help.js"))
(:= parse  (require "./parse.js"))

(:= root this)

(:= toStr _.toStr)
(:= obArr _.obArr)
(:= obObj _.obObj)
(:= log _.log)
(:= isInt _.isInt)
(:= isSymbol _.isSymbol)
(:= pairize _.pairize)
(:= partition _.partition)


; treeToJs :: {string (expr string number)} -> object
(:= (treeToJs extra)

        (= extra (|| extra {}))

        (:= (getIndent i)
                (:= res "")
                (while (>= i 1) (+= res "    ") (-- i))
                res)

        (:= branchers ["if" "switch" "try"])
        (:= blockCreators (branchers.concat ["for" "while"]))
        (:= noWrap ["" "=" "()" "return" "throw" "new" "for"])
        (:= openSpace ["->" ""])

        (:= (isIn set) (-> (e)  (&& (. e 0) (in (. e 0) set))))

        (:= isBrancher (isIn branchers))
        (:= isBlockCreator (isIn blockCreators))

        (:= (prepBranch e)
                (if (&& (. e 0) (=== (. e 0) ",")) (. e (slice 1)) [e]))

        (:= (getSemi e)
                (if (|| (isBlockCreator e) (. e c)) "" ";"))

        (:= (sBlock sep) (-> (exprs p i) 
                (if (=== exprs.length 0) "()"
                        (+ "(" (. (forIn exprs k e (toJs e "()" i)) (join sep)) ")"))))

        (:= argBlock (sBlock ", "))
        (:= iniBlock (sBlock "; "))

        (:= (getRef e i) 
                (if (&& (=== (typeof e) "string") (isSymbol.exec e))
                        (+ "." e)
                    (&& (=== (toStr.call e) obObj) (=== (_.key e) "a"))
                        (+ "[" (toJs (. e a 0) "." i) "]")
                        (+ "[" (toJs e "." i) "]")))

        (:= (wrap res p)
                (if (in p noWrap) res (+ "(" res ")")))

        (:= (selfCollect e p i)
                (:= pre (e.slice 0 -1))
                (:= last (e.slice -1))
                (wrap (toJs [ ["->" [] [":=" "res_" {a []}] 
                               (pre.concat [["res_.push" (. last 0)]]) "res_"] ] p i) 
                      (. e 0))

        ; primitive exprs - may need to eval to something depending on p
        (:= prim {
                "rgx" (-> (e p i) ; (rgx "expr" flag)
                        (+ "/" (toJs (. e 1) "rgx" i) "/" (toJs (. e 2) "rgx" i)))

                ":=" (-> (e p i)
                        (if (> e.length 2)
                                (+ "var " ((. prim "=") e p i))
                                (+ "var " (. e 1))))

                "=" (-> (e p i)
                        (if (! (. e 2))
                                (toJs (. e 1) "=" i)

                            (=== (toStr.call (. e 1)) obArr)
                                (+ (toJs (. e 1 0) "=" i) " = " (toJs (. ["->" (. e 1 (slice 1))] (concat (. e (slice 2)))) "=" i))
                                
                                (+ (toJs (. e 1) "=" i) " = " (toJs (. e 2) "=" i))))

                "." (-> (e p i) ; member access, chaining, slices

                        (:= mem (. e 1))
                        (:= res (toJs mem "." i))
                        (:= parts (. e (slice 2)))

                        (forIn parts k part

                                (if (=== (typeof part) "string") ; atom
                                        (+= res (getRef part i)) ; [0]  |  .y

                                    (=== (toStr.call part) obArr) ; ()

                                        (if (. prim [(. part 0)])
                                                (+= res "[" ((. prim [(. part 0)]) part "." i) "]") ; x[(true ? 1 : 2)]
                                                (+= res (getRef (. part 0) i) (argBlock (. part (slice 1)) "." i))) ; .x(1, 2, y(z))  |  [z(x)](1,2)

                                    (=== (toStr.call part) obObj)

                                        (if (=== (_.key part) "s")
                                                (+= res "[\"" part.s "\"]") ; ["x y"]

                                            (=== (_.key part) "a")
                                                (if (=== part.a.length 2)
                                                        (+= res ".slice" (argBlock (. part a [0 2]) "slice" i)) ; .slice(0, x(y))
                                                        (+= "[" (toJs (. part a 0) "." i) "]"))) ; [x(y)]

                                        (throw (new Error "Invalid reference"))))
                        res)

                "->" (-> (e p i) ; (-> (p...) body...)
                        (:= res (+ "function (" (. e 1 (join ", ")) ") " (block (. e (slice 2)) "->" i)))
                        (if (=== p "") (+ "(" res ")") (wrap res p)))

                "throw" (-> (e p i) (+ "throw " (toJs (. e 1) "throw" i)))

                "return" (-> (e p i) (+ "return " (toJs (. e 1) "return" i)))

                "?" (-> (e p i)
                        (wrap (+ (toJs (. e 1) "()" i) " ? " (toJs (. e 2) "()" i) " : " (toJs (. e 3) "()" i)) p))

                "if" (-> (e p i) ; (?? (< 2 3) 4 5)

                        (if (in p openSpace)

                                (, (:= prd (. e (slice 1)))

                                   (:= res (+ "if (" (toJs (. prd 0) "()" i) ") " (block (prepBranch (. prd 1)) p i)))
                                   (prd.splice 0 2)

                                   (while (> prd.length 0)

                                          (if (=== prd.length 1)
                                              (, (+= res " else " (block (prepBranch (. prd[0])) p i))
                                                 (prd.splice 0 1))

                                              (, (+= res (+ " else if (" (toJs (. prd 0) "()" i) ") " (block (prepBranch (. prd 1)) p i)))
                                                 (prd.splice 0 2))))
                                   res)

                                (if (=== e.length 4) 
                                        (toJs (. ["?"] (concat (. e (slice 1)))) p i) ; use ternary
                                        (wrap (toJs [["->" [] e]] p i) "if")))) ; wrap in self-calling func

                "switch" (-> (e p i) ; rewrite as an 'if' to avoid handling weird block semantics of switch

                        (:= res ["if"])
                        (:= match (. e 1))
                        (:= prd (. e (slice 2)))

                        (while (> prd.length 0)

                                (if (=== prd.length 1)
                                        (, (res.push (. prd 0)) ; default case
                                           (prd.splice 0 1))
                                
                                        (, (= res (res.concat [["===" match (. prd 0)] (. prd 1)]))
                                           (prd.splice 0 2)))
                        (toJs res p i)))

                "try" (-> (e p i) ; (try e (, stuff) (, catch) (, finally))

                        (if (in p openSpace)

                                (, (:= res (+ "try " (block (prepBranch (. e 2)) p i)))
                                   (if (. e 3)
                                       (+= res (+ " catch (" (toJs (. e 1) "()" i) ") " (block (prepBranch (. e 3)) p i))))
                                   (if (. e 4)
                                       (+= res (+ " finally " (block (prepBranch (. e 4)) p i))))
                                   res)

                                (wrap (toJs [["->" [] e]] p i) "try")))

                'while': (e, p, i) -> # (while clause body ...)

                        if p in openSpace

                                'while ' + iniBlock([e[1]], 'while', i) + ' ' + block(e[2..], '', i)
                        else
                                selfCollect e, p, i

                'for': (e, p, i) -> # (for (clauses...) body...) - just the basic js for

                        if p in openSpace

                                'for ' + iniBlock(e[1], 'for', i) + ' ' + block(e[2..], '', i)
                        else
                                selfCollect e, p, i

                'forIn': (e, p, i) -> # (for-in coll k v body...)

                        coll = e[1]
                        k    = e[2]
                        v    = e[3]
                        body = e[4..]

                        toJs ['for', [['=', k, '0'], ['<', k, ['.', coll, 'length']], ['++', k]], ['=', v, ['.', coll, {a: [k]}]]].concat(body), p, i


        # put operators into primitives
        binaryPr = (sym) -> (e, p, i) ->
                wrap (toJs(e_, sym, i) for e_ in e[1..]).join(' ' + sym + ' '), p # always eval to something

        binaryAlwaysWrap = (sym) -> (e, p, i) ->
                wrap (toJs(e_, sym, i) for e_ in e[1..]).join(' ' + sym + ' '), 'wrap'

        binaryChain = (sym) -> (e, p, i) -> # (x s y && y s b && b s a)
                if e.length > 3

                        left = e[1]
                        res  = ['&&']

                        for e_ in e[2..]
                                res.push [sym, left, e_]
                                left = e_

                        toJs res, p, i
                else
                        wrap (toJs(e[1], sym, i) + ' ' + sym + ' ' + toJs(e[2], sym, i)), p

        unaryPost = (sym) -> (e, p, i) ->
                wrap e[1] + sym, p

        unaryPr = (sym) -> (e, p, i) ->
                if e.length < 3
                        arg = e[1]
                else
                        arg = e[1..]

                wrap sym + ' ' + toJs(arg, p, i), p

        for op in ['+=', '*=', '/=', '%=', '-=', '<<=', '>>=', '>>>=', '&=', '^=', '|=']
                prim[op] = binaryPr op

        for op in ['*', '/', '%', '+', '-', '&&', '||', ',']
                prim[op] = binaryAlwaysWrap op

        for op in ['==', '!=', '===', '!==', '>', '>=', '<', '<=','in', 'of', 'instanceof']
                prim[op] = binaryChain op

        for op in ['++','--']
                prim[op] = unaryPost op

        for op in ['typeof', 'new', 'throw', '!']
                prim[op] = unaryPr op

        # extend with any extra primitives
        for k, v of extra
                prim[k] = v

        # BLOCK and TOJS form the core
        block = (exprs, p, i = 0) ->

                # p can only ever be '->' or '' here - it is reset when entering a block.
                # indent all children
                # a block may need to return its last elem
                # everything at top level of block gets appended with a ';' if it is not a block
                # if you need to ret, and last item is a branch, do the cond, reting all its children
                # if you need to ret, and last item is a loop, make the loop a comprehension
                # reset stk on all top-level elems
                # noBrk is used in switch statements

                pre  = exprs.slice 0, -1
                last = exprs.slice -1

                ind = getIndent i
                i_ = i + 1 # increment indentation level for children

                res = '{\n'

                if pre.length > 0 # pre elements
                        for e in pre
                                res += ind + toJs(e, '', i_)  + getSemi(e) + '\n' # reset par - in open block

                if last.length is 1 # last element
                        res += ind
                        e = last[0]

                        if isBrancher(e)
                                res += toJs(e, p, i_) + getSemi(e)

                        else if p is '->'
                                if e[0] and e[0] is 'throw'
                                        res += 'throw ' + (toJs e[1], 'throw', i_) + getSemi(e)
                                else
                                        res += (toJs ['return', e], p, i_) + getSemi(e)
                        else
                                res += toJs(e, p, i_) + getSemi(e)

                res + '\n' + getIndent(i - 1) + '}'


        # p is the parent expression, or '', which is a normal block, or '->', which is a function body
        # i is the indentation level, which is increased inside blocks
        toJs = (expr, p = '', i) ->

                if typeof expr is 'string'

                        # base primitive: atom
                        expr

                else if toStr.call(expr) is obArr

                        first = expr[0]

                        if first

                                if prim[first]

                                        # primitive expr - go to table for a solution
                                        prim[first] expr, p, i

                                else
                                        # user-defined: function call
                                        toJs(first, '', i) + argBlock(expr[1..], first, i)
                        else
                                ''
                else
                        exprKey = _.key expr

                        if exprKey is 's'

                                # base primitive: string literal
                               '"' + expr.s + '"'

                        else if exprKey is 'a'

                                # base primitive: array literal
                                '[' + (toJs e, '[]', i for e in expr.a).join(', ') + ']'

                        else if exprKey is 'o'

                                # base primitive: object literal
                                pairs = pairize expr.o
                                '{' + (toJs(pair[0], '{}', i) + ': ' + toJs(pair[1], '{}', i) for pair in pairs).join(', ') + '}'

                        else if exprKey is 'c'
                                '//' + expr.c

                        else
                                # unhandled case
                                throw new Error('Unhandled case: ' + util.inspect(expr))

        @toJs = toJs
        @block = block
        @trans = (tree, callback) ->

                callback null, block(tree[0], '', 0)[2..-2]

        @


root.treeToJs = new treeToJs()
